# 1_建立统一错误处理框架
# Establish Unified Error Handling Framework

## 背景 / Background
- 现有失败处理散落在 `selenium_fetcher.py`、`webfetcher.py` 等处，缺乏统一结构，后续扩展（如 Playwright）时难以维护。
  Current failure handling is scattered across multiple files, lacking unified structure for future extensions.
- 之前方案建议新增 `error_reporter.py`，封装错误分类、排错建议与 Markdown 生成。
  Previous plan suggested adding `error_reporter.py` to encapsulate error classification and troubleshooting.

## 目标 / Goals
- 在项目中引入独立的错误报告模块，统一管理错误类型、排查步骤和输出模板。
  Introduce independent error reporting module for unified error management.
- 为未来的多引擎扩展（Selenium、Playwright、CDP）提供一致的错误处理接口。
  Provide consistent error handling interface for future multi-engine extensions.

## 验收标准 / Acceptance Criteria
1. 新增 `error_reporter.py`，提供错误分类、排障建议、失败 Markdown 生成等能力。
   Add `error_reporter.py` with error classification, troubleshooting, and failure report generation.
2. `webfetcher.py` 与 `selenium_fetcher.py` 调用该模块，去除重复代码。
   Integrate module into existing code to remove duplication.
3. 单元测试覆盖至少三类错误场景的处理。
   Unit tests cover at least three error scenarios.
4. 文档说明如何扩展新的错误类型。
   Documentation on extending new error types.

## 架构评审结果 / Architecture Review Result

⚠️ **需要调整** - 现有方案与已有代码存在冲突，需要修改实施路径

**识别的问题 / Issues Identified:**
1. `webfetcher.py`已包含`generate_failure_markdown()`函数（第4490行）
2. 需要考虑与现有错误处理的集成路径
3. 错误分类需要更完善的层次结构

## 实施步骤 / Implementation Steps

### Phase 1: 错误处理基础架构 [2小时]

**文件变更清单 / File Changes:**
```
新增文件 / New Files:
├── error_handler.py              # 位置：项目根目录
└── tests/test_error_handler.py   # 位置：tests目录

修改文件 / Modified Files:
├── webfetcher.py
│   ├── 行4490-4540: 重构generate_failure_markdown()
│   └── 行4870-4925: 调整错误处理调用
└── selenium_fetcher.py
    ├── 行120-135: 统一异常类定义
    └── 行498-651: 集成错误分类器
```

**实施细节 / Implementation Details:**

1. **创建error_handler.py模块**
   ```python
   # 接口定义（非实现代码）
   class ErrorCategory(Enum):
       NETWORK_CONNECTION = "network_connection"
       BROWSER_INIT = "browser_initialization"
       PAGE_LOAD = "page_loading"
       PERMISSION = "permission_denied"
       DEPENDENCY = "missing_dependency"
       TIMEOUT = "operation_timeout"
       UNKNOWN = "unknown_error"

   class ErrorClassifier:
       def classify(self, exception: Exception) -> ErrorCategory
       def get_error_chain(self, exception: Exception) -> List[Exception]
       def extract_root_cause(self, exception: Exception) -> str

   class ErrorReporter:
       def __init__(self, classifier: ErrorClassifier)
       def generate_markdown_report(self, url, metrics, exception) -> str
       def get_troubleshooting_guide(self, category: ErrorCategory) -> Dict
   ```

2. **验证命令:**
   ```bash
   # 测试错误分类器
   python -c "from error_handler import ErrorClassifier; print('Module loaded')"
   ```

### Phase 2: 集成现有代码 [3小时]

**修改webfetcher.py:**
- 位置：第4490-4540行
- 目标：保留函数签名，内部调用error_handler
- 方向：
  ```python
  # 伪代码示例
  def generate_failure_markdown(url, metrics, exception=None):
      from error_handler import ErrorReporter, ErrorClassifier
      classifier = ErrorClassifier()
      reporter = ErrorReporter(classifier)
      return reporter.generate_markdown_report(url, metrics, exception)
  ```

**修改selenium_fetcher.py:**
- 位置：第498-651行（异常处理块）
- 目标：统一错误分类和消息格式
- 方向：在catch块中添加分类逻辑

**验证命令:**
```bash
# 测试集成后的错误处理
python wf.py -s https://example.com
# 预期：错误报告包含分类信息
```

### Phase 3: 测试与文档 [1小时]

**测试场景:**
```bash
# 场景1：Chrome连接失败
pkill -f "remote-debugging-port=9222"
python wf.py -s https://example.com
# 预期输出：错误分类为BROWSER_INIT

# 场景2：页面超时
python wf.py -s https://httpstat.us/200?sleep=30000 --timeout 5
# 预期输出：错误分类为TIMEOUT

# 场景3：SSL错误
python webfetcher.py https://expired.badssl.com/
# 预期输出：错误分类为NETWORK_CONNECTION
```

**文档更新:**
- 创建：docs/error_handling_guide.md
- 更新：README.md添加错误处理章节

## 架构优势 / Architecture Benefits
1. **可维护性 / Maintainability**：集中管理所有错误处理逻辑
2. **可扩展性 / Extensibility**：轻松添加新的错误类型和引擎支持
3. **一致性 / Consistency**：统一的错误报告格式和用户体验
4. **可测试性 / Testability**：独立模块便于单元测试

## 备注 / Notes
- 建议在完成Task 1和Task 2后再推进本任务，确保接口稳定。
  Recommend starting after Task 1 and Task 2 to ensure stable interfaces.
- 保持最小可行实现，避免过度工程。
  Keep minimal viable implementation, avoid over-engineering.
- 此框架将为项目长期维护提供重要基础。
  This framework provides important foundation for long-term maintenance.
